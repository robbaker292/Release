<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8"/>
		<title>HTML 5 Canvas example</title>
		<script>

			var circles = [];

		
			/** A labelled circle */
			function Circle(label,r,x,y) {
				this.label = label;
				this.r = r;
				this.x = x;
				this.y = y;
			}


			function Rectangle(x,y,width,height) {
				this.x = x;
				this.y = y;
				this.width = width;
				this.height = height;
			}
			
			function Point(x,y) {
				this.x = x;
				this.y = y;
			}

			
			/** Find the circle with the given label */
			function circleWithLabel(label, circles) {
				for (var i = 0; i <  circles.length; i++) {
					if(circles[i].label==label) {
						return circles[i];
					}
				}
				return null;
			}




			/** Finds a rectangle that covers the given circle */
			function circlesLimit(circles) {
				var minX = 0;
				var minY = 0;
				var maxX = 0;
				var maxX = 0;
				for (var i = 0; i < circles.length; i++) {
					if(i == 0) {
						minX = circles[i].x - circles[i].r;
						minY = circles[i].y - circles[i].r;
						maxX = circles[i].x + circles[i].r;
						maxY = circles[i].y + circles[i].r;
					} else {
						if(minX > circles[i].x - circles[i].r) {
							minX = circles[i].x - circles[i].r;
						}
						if(minY > circles[i].y - circles[i].r) {
							minY = circles[i].y - circles[i].r;
						}
						if(maxX < circles[i].x + circles[i].r) {
							maxX = circles[i].x + circles[i].r;
						}
						if(maxY < circles[i].y + circles[i].r) {
							maxY = circles[i].y + circles[i].r;
						}
					}
				}
				var rectangle = new Rectangle(minX,minY,maxX-minX,maxY-minY);
				return rectangle;
			}
			


			/** Tests to see if the point is in the circle */
			function inCircle(circle,x,y) {
				if(distance(circle.x,circle.y,x,y) < circle.r) {
					return true;
				}
				return false;
			}
			
			
			/** Distance between two points - pythagoras */
			function distance(x1,y1,x2,y2) {
				return Math.sqrt((x1-x2) * (x1-x2) + (y1-y2) * (y1-y2));
			}
			
			
			/**
			  Find out if the point is in the zone. The zone is specified
			  by the circles it is in and the circles it is out of. All
			  the circles should be in one of the two sets.
			*/
			function inZone(inCircles,outCircles,x,y) {
				for (var i = 0; i < inCircles.length; i++) {
					if(!inCircle(inCircles[i],x,y)) {
						return false;
					}
				}
				for (var i = 0; i < outCircles.length; i++) {
					if(inCircle(outCircles[i],x,y)) {
						return false;
					}
				}
				return true;

			}
			
			
			/**
			  Find out if the rectangle is completely in the zone. The zone is specified
			  by the circles it is in and the circles it is out of. All
			  the circles should be in one of the two sets. This tests the oorner
			  points, so some oddly shaped zones may return an incorrect true.
			*/
			function rectangleInZone(circlesInZone,circlesOutZone, minX,maxX,minY,maxY) {
				if(!inZone(circlesInZone,circlesOutZone, minX,minY)) {
					return false;
				}
				if(!inZone(circlesInZone,circlesOutZone, minX,maxY)) {
					return false;
				}
				if(!inZone(circlesInZone,circlesOutZone, maxX,minY)) {
					return false;
				}
				if(!inZone(circlesInZone,circlesOutZone, maxX,maxY)) {
					return false;
				}
				return true;
			}


			/**
			  Given that the zone in in the inZone circles, this finds
			  the circles that do not contain the zone.
			*/
			function getOutZones(circles,inZone) {
				var outZone = [];
				for (var i = 0; i < circles.length; i++) {
					var circleInZone = false;
					for (var j = 0; j < inZone.length; j++) {
						if(circles[i] == inZone[j]) {
							circleInZone = true;
							outCircle = circles[i];
						}
					}
					if(!circleInZone) {
						outZone.push(circles[i]);
					}
				}
				return outZone;
			}
			

			/**
				Find the points in the given zone in a grid based on the parameters.
			*/
			function findPointsInZone(displayLimit,xStep,yStep,circlesInZone,circlesOutZone) {
			
				var points = [];
				for(var x = displayLimit.x+xStep/2; x <= displayLimit.x + displayLimit.width; x = x + xStep) {
					for(var y = displayLimit.y+yStep/2; y <= displayLimit.y + displayLimit.height; y = y + yStep) {
						var pointInZone = inZone(circlesInZone, circlesOutZone,x,y);
						if(pointInZone) {
							points.push(new Point(x,y));
						}
					}
				}
				return points;
			}
			
			
			/** Finds a minimum number of points in a zone, or return empty list*/
			function findSufficientPointsInZone(circlesInZone,circlesOutZone) {
				var displayLimit = circlesLimit(circlesInZone);
				var gridSide = 3;
				var xStep = displayLimit.width/gridSide;
				var yStep = displayLimit.height/gridSide;
				
				var zonePointsX = [];
				var zonePointsY = [];
				
				var pointsInZone = [];
				while(pointsInZone.length < 10) {
					if(xStep < 1 && yStep < 1) {
						console.log("zone not found");
							return [];
						}
					pointsInZone = findPointsInZone(displayLimit,xStep,yStep,circlesInZone,circlesOutZone)
					xStep = xStep/2;
					yStep = yStep/2;
				}
				return pointsInZone;
			}
			
			
			
			/** For each zone, finds circles that the zones are in. Returns a list of lists */
			function zoneFinder(zoneStrings,circles) {
				var ret = [];
				for (var i = 0; i <  zoneStrings.length; i++) {
					var zoneString = zoneStrings[i];
					var nextZone = [];
					for (var j = 0; j < zoneString.length; j++) {
						var circleLabel = zoneString[j];
						var circle = circleWithLabel(circleLabel,circles);
						nextZone.push(circle);
					}
					ret.push(nextZone);
				}
				return ret;
			}
			
			
			/**
			  Expand a rectangle until it fills the zone as much as possible
			*/
			function findRectangle(point,circlesInZone,circlesOutZone) {

				var minX = point.x;
				var maxX = point.x+1;
				var minY = point.y;
				var maxY = point.y+1;
				var moveDistance = circlesInZone[0].r/4;
			
				while (moveDistance > 0.5) {

					var noMove = true;
					
					if(rectangleInZone(circlesInZone,circlesOutZone, minX-moveDistance,maxX,minY,maxY)) {
						noMove = false;
						minX = minX-moveDistance
					}
					if(rectangleInZone(circlesInZone,circlesOutZone, minX,maxX+moveDistance,minY,maxY)) {
						noMove = false;
						maxX = maxX+moveDistance
					}
					if(rectangleInZone(circlesInZone,circlesOutZone, minX,maxX,minY-moveDistance,maxY)) {
						noMove = false;
						minY = minY-moveDistance
					}
					if(rectangleInZone(circlesInZone,circlesOutZone, minX,maxX,minY,maxY+moveDistance)) {
						noMove = false;
						maxY = maxY+moveDistance
					}
					
					if(noMove) {
						moveDistance = moveDistance/2
					}
				}
			
				var ret = new Rectangle(minX, minY, maxX-minX, maxY-minY);
				return ret;
			}


			
			/**
			  This finds a biggest contained rectangle for a zone, specified by
			  the circles containing the zone and the circles that are outside the
			  zone.
			*/
			function findZoneRectangle(circlesInZone,circlesOutZone) {

				var pointsInZone = findSufficientPointsInZone(circlesInZone,circlesOutZone);
				
				if(pointsInZone.length == 0) {
					return new Rectangle(0,0,0,0);
				}
				var biggestRectangle;
				var biggestArea = 0;
				for (var i = 0; i < pointsInZone.length; i++) {
					var rectangle = findRectangle(pointsInZone[i],circlesInZone,circlesOutZone);
					if(rectangle.width*rectangle.height > biggestArea) {
						biggestRectangle = rectangle;
						biggestArea = rectangle.width*rectangle.height;
					}
				}
				return biggestRectangle;
			}
			
			
			/**
			  This finds a biggest contained rectangle for each zone. The rectangles
			  are returned in array, in the same order as the zones. The zones are
			  specified by an array of strings. The circles should be an array
			  of all the circles in the diagram
			*/
			function findZoneRectangles(zoneStrings, circles) {

				var zones = zoneFinder(zoneStrings,circles);

				var rectangles = [];
				
				// iterate through the zones, finding the best rectangle for each zone
				for (var i = 0; i <  zones.length; i++) {
					var circlesInZone = zones[i];
					
					var circlesOutZone = getOutZones(circles, circlesInZone);
					var rectangle = findZoneRectangle(circlesInZone,circlesOutZone);
					
					rectangles.push(rectangle);
				}
				return rectangles;
			}


			function parseFile(input, zones){
				var txtFile = new XMLHttpRequest();

				txtFile.open("GET", "/runJava.php?input="+input, true);

				
				txtFile.onreadystatechange = function() {
					if (txtFile.readyState != 4) {
						window.status="Loading";
					} else {
						if (txtFile.status === 200) { 		
							decodeCsv(txtFile.responseText.split("\n"));
							//console.log(circles,zones);
							testRegion(zones);
						}
					}
				};
				txtFile.send(null);
			}

			function decodeCsv(csv){
				//console.log(csv);
				//use 1 as first row of input are label
				for (var i = 1; i < csv.length-1; i++){
					var result = csv[i].split(",");
					var c = new Circle(result[0], parseInt(result[3]), parseInt(result[1]), parseInt(result[2]));
					circles.push(c);
					//console.log(circles);
				}
				
			}
			
						
			function testRegion(zones) {
				var canvas = document.getElementById('example');
				var context = canvas.getContext('2d');

//				var circle1 = new Circle("a",40,80,80);
//				var circles = [circle1];

				//var circle1 = new Circle("a",40,80,80);
				//var circle2 = new Circle("b",40,110,110);
				//var circle3 = new Circle("c",40,140,95);
				//var circles = [circle1,circle2,circle3];
				

				//parseFile(input);

				//console.log(circles, zones);
/*
				var circle1 = new Circle("a",40,80,80);
				var circle2 = new Circle("b",45,110,110);
				var circle3 = new Circle("c",50,170,130);
				var circle4 = new Circle("d",30,300,50);
				var circles = [circle1,circle2,circle3,circle4];
				
//				var zones = ['a', 'ab', 'd'];
				var zones = ['b'];
*/

				for (var i = 0; i < circles.length; i++) {
					circle = circles[i];
					context.beginPath();
					context.arc(circle.x, circle.y, circle.r, 0, Math.PI*2, false); 
					context.lineWidth = 1;
					context.strokeStyle = 'blue';
					context.stroke();
					//console.log(circle);
				}
								
						
				var rectangles = findZoneRectangles(zones, circles);
								
				context.fillStyle = "green";
				for (var i = 0; i < rectangles.length; i++) {
					context.fillRect(rectangles[i].x, rectangles[i].y, rectangles[i].width, rectangles[i].height);
				}

			}

			function main(){
				var zones = "a ab ac bc".split(" ");
				var input = "a b c ab ac bc abc";


				parseFile(input, zones);
			}
			
						
	</script>
	</head>
	<body onload="main();">
		<canvas id="example" width="400" height="200">
			Testing zone rectangle finder
		</canvas>
		
	</body>
</html>